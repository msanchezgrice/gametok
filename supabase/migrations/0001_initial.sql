-- Gameplay metadata
create table if not exists public.games (
  id uuid primary key default gen_random_uuid(),
  slug text unique not null,
  title text not null,
  short_description text not null,
  genre text not null,
  play_instructions text not null,
  estimated_duration_seconds integer not null default 90,
  runtime_version text not null default '1.0.0',
  status text not null default 'draft',
  tags text[] not null default '{}',
  thumbnail_url text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.game_variants (
  id uuid primary key default gen_random_uuid(),
  game_id uuid not null references public.games(id) on delete cascade,
  entry_html_path text not null,
  build_hash text not null,
  build_size_kb integer not null,
  orientation text not null default 'responsive',
  min_app_version text not null default '1.0.0',
  created_at timestamptz not null default now()
);

create table if not exists public.game_assets (
  id uuid primary key default gen_random_uuid(),
  game_id uuid not null references public.games(id) on delete cascade,
  asset_type text not null,
  storage_path text not null,
  checksum text,
  created_at timestamptz not null default now()
);

-- Player state
create table if not exists public.user_profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  handle text,
  settings jsonb not null default '{}',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.favorites (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  game_id uuid not null references public.games(id) on delete cascade,
  created_at timestamptz not null default now(),
  unique (user_id, game_id)
);

create table if not exists public.game_sessions (
  id uuid primary key default gen_random_uuid(),
  game_id uuid not null references public.games(id) on delete set null,
  user_id uuid references auth.users(id) on delete set null,
  source text not null default 'feed',
  started_at timestamptz not null default now(),
  ended_at timestamptz,
  total_seconds integer,
  completed boolean not null default false,
  score numeric,
  restarts integer not null default 0,
  shares integer not null default 0,
  heartbeats integer not null default 0,
  device_info jsonb not null default '{}'
);

create table if not exists public.session_events (
  id bigint generated by default as identity primary key,
  session_id uuid not null references public.game_sessions(id) on delete cascade,
  event_type text not null,
  payload jsonb not null default '{}',
  occurred_at timestamptz not null default now()
);

create table if not exists public.shares (
  id bigint generated by default as identity primary key,
  session_id uuid references public.game_sessions(id) on delete cascade,
  user_id uuid references auth.users(id) on delete set null,
  game_id uuid not null references public.games(id) on delete cascade,
  target text not null,
  shared_at timestamptz not null default now()
);

create table if not exists public.likability_scores (
  id bigint generated by default as identity primary key,
  game_id uuid not null references public.games(id) on delete cascade,
  genre text not null,
  score numeric not null,
  components jsonb not null,
  sample_size integer not null,
  computed_at timestamptz not null default now()
);

create table if not exists public.daily_metrics (
  id bigint generated by default as identity primary key,
  game_id uuid not null references public.games(id) on delete cascade,
  metric_date date not null,
  plays integer not null default 0,
  completions integer not null default 0,
  shares integer not null default 0,
  favorites integer not null default 0,
  total_session_seconds bigint not null default 0,
  constraint daily_metrics_unique unique (game_id, metric_date)
);

-- Indexes
create index if not exists idx_game_sessions_game_id on public.game_sessions (game_id);
create index if not exists idx_game_sessions_user_id on public.game_sessions (user_id);
create index if not exists idx_session_events_session on public.session_events (session_id);
create index if not exists idx_favorites_user on public.favorites (user_id);
create index if not exists idx_shares_game on public.shares (game_id);
create index if not exists idx_likability_scores_game on public.likability_scores (game_id);

-- RLS configuration
alter table public.games enable row level security;
alter table public.game_variants enable row level security;
alter table public.game_assets enable row level security;
alter table public.user_profiles enable row level security;
alter table public.favorites enable row level security;
alter table public.game_sessions enable row level security;
alter table public.session_events enable row level security;
alter table public.shares enable row level security;
alter table public.likability_scores enable row level security;
alter table public.daily_metrics enable row level security;

create policy "Public can read games" on public.games for select using (true);
create policy "Service role manages games" on public.games for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');

create policy "Service role manages variants" on public.game_variants for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');
create policy "Service role manages assets" on public.game_assets for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');
create policy "Service role manages sessions" on public.game_sessions for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');
create policy "Service role manages session events" on public.session_events for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');
create policy "Service role manages shares" on public.shares for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');
create policy "Service role manages likability" on public.likability_scores for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');
create policy "Service role manages metrics" on public.daily_metrics for all using (auth.role() = 'service_role') with check (auth.role() = 'service_role');

create policy "Public read likability" on public.likability_scores for select using (true);
create policy "Public read metrics" on public.daily_metrics for select using (true);

create policy "Users manage own profile" on public.user_profiles for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Users manage favorites" on public.favorites for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Users read own sessions" on public.game_sessions for select using (auth.uid() = user_id);
create policy "Insert sessions" on public.game_sessions for insert with check (auth.uid() = user_id or auth.uid() is null);
create policy "Update own sessions" on public.game_sessions for update using (auth.uid() = user_id) with check (auth.uid() = user_id);

create policy "Users read own session events" on public.session_events for select using (
  auth.uid() = (
    select user_id from public.game_sessions where id = session_id
  )
);

create policy "Users manage shares" on public.shares for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- helper view for analytics
create or replace view public.game_engagement_summary as
select
  gs.game_id,
  date_trunc('day', gs.started_at) as event_day,
  count(distinct gs.id) as sessions,
  sum(case when gs.completed then 1 else 0 end) as completions,
  sum(gs.total_seconds) as total_seconds,
  sum(gs.restarts) as total_restarts,
  sum(gs.shares) as total_shares
from public.game_sessions gs
where gs.started_at >= now() - interval '30 days'
group by gs.game_id, date_trunc('day', gs.started_at);
